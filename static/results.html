<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eval API - Results Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="results.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ“Š Evaluation Dashboard</h1>
            <div class="status">
                <div class="status-indicator"></div>
                <span class="status-text">Live Updates Active</span>
            </div>
        </header>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Total Evaluations</div>
                <div class="stat-value" id="totalEvals">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Pass Rate</div>
                <div class="stat-value" id="passRate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg Latency</div>
                <div class="stat-value" id="avgLatency">0ms</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Active Models</div>
                <div class="stat-value" id="activeModels">0</div>
            </div>
        </div>

        <div class="charts-grid">
            <div class="card">
                <div class="chart-title">Pass/Fail Distribution</div>
                <canvas id="verdictChart"></canvas>
            </div>
            <div class="card">
                <div class="chart-title">Model Performance</div>
                <canvas id="modelChart"></canvas>
            </div>
            <div class="card chart-card">
                <div class="chart-title">Latency Trend (Last 20)</div>
                <canvas id="latencyChart"></canvas>
            </div>
            <div class="card chart-card">
                <div class="chart-title">Evaluations Over Time</div>
                <canvas id="timelineChart"></canvas>
            </div>
        </div>

        <div class="card">
            <div class="chart-title">Recent Evaluations</div>
            <table>
                <thead>
                    <tr>
                        <th>Timestamp</th>
                        <th>Model</th>
                        <th>Prompt</th>
                        <th>Verdict</th>
                        <th>Latency</th>
                    </tr>
                </thead>
                <tbody id="resultsBody">
                    <tr><td colspan="5" class="empty-state">Loading data...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let ws;
        let charts = {};
        let historyData = [];

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/api/v1/ws`);
            
            ws.onopen = () => console.log('WebSocket connected');
            ws.onmessage = (e) => {
                const update = JSON.parse(e.data);
                handleRealtimeUpdate(update);
            };
            ws.onerror = (e) => console.error('WebSocket error:', e);
            ws.onclose = () => {
                console.log('WebSocket closed, reconnecting...');
                setTimeout(connectWebSocket, 3000);
            };
        }

        function handleRealtimeUpdate(update) {
            console.log('Real-time update:', update);
            fetchHistory();
        }

        async function fetchHistory() {
            try {
                const res = await fetch('/api/v1/evals/history');
                const data = await res.json();
                historyData = data.results || [];
                updateDashboard();
            } catch (e) {
                console.error('Failed to fetch history:', e);
            }
        }

        function updateDashboard() {
            updateStats();
            updateCharts();
            updateTable();
        }

        function updateStats() {
            const total = historyData.length;
            const passed = historyData.filter(e => e.judge_verdict === 'Pass').length;
            const passRate = total > 0 ? Math.round((passed / total) * 100) : 0;
            
            const latencies = historyData
                .map(e => e.model_output ? parseFloat(e.model_output.match(/\d+/)?.[0] || 0) : 0)
                .filter(l => l > 0);
            const avgLatency = latencies.length > 0 
                ? Math.round(latencies.reduce((a, b) => a + b, 0) / latencies.length)
                : 0;
            
            const models = new Set(historyData.map(e => e.model).filter(Boolean));
            
            document.getElementById('totalEvals').textContent = total;
            document.getElementById('passRate').textContent = passRate + '%';
            document.getElementById('avgLatency').textContent = avgLatency + 'ms';
            document.getElementById('activeModels').textContent = models.size;
        }

        function updateCharts() {
            updateVerdictChart();
            updateModelChart();
            updateLatencyChart();
            updateTimelineChart();
        }

        function updateVerdictChart() {
            const verdicts = historyData.reduce((acc, e) => {
                const v = e.judge_verdict || 'No Judge';
                acc[v] = (acc[v] || 0) + 1;
                return acc;
            }, {});

            const ctx = document.getElementById('verdictChart').getContext('2d');
            if (charts.verdict) charts.verdict.destroy();
            
            charts.verdict = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(verdicts).map(label => label === 'No Judge' ? 'Error/No Judge' : label),
                    datasets: [{
                        data: Object.values(verdicts),
                        backgroundColor: ['#28a745', '#dc3545', '#ffc107', '#6c757d']
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { legend: { position: 'bottom' } }
                }
            });
        }

        function updateModelChart() {
            const models = historyData.reduce((acc, e) => {
                if (!e.model) return acc;
                if (!acc[e.model]) acc[e.model] = { pass: 0, fail: 0 };
                if (e.judge_verdict === 'Pass') acc[e.model].pass++;
                else if (e.judge_verdict === 'Fail') acc[e.model].fail++;
                return acc;
            }, {});

            const ctx = document.getElementById('modelChart').getContext('2d');
            if (charts.model) charts.model.destroy();
            
            charts.model = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(models),
                    datasets: [
                        {
                            label: 'Pass',
                            data: Object.values(models).map(m => m.pass),
                            backgroundColor: '#48bb78'
                        },
                        {
                            label: 'Fail',
                            data: Object.values(models).map(m => m.fail),
                            backgroundColor: '#f56565'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: { y: { beginAtZero: true } }
                }
            });
        }

        function updateLatencyChart() {
            const recent = historyData.slice(0, 20).reverse();
            const latencies = recent.map((e, i) => ({
                x: i + 1,
                y: parseFloat(e.model_output?.match(/\d+/)?.[0] || 0)
            }));

            const ctx = document.getElementById('latencyChart').getContext('2d');
            if (charts.latency) charts.latency.destroy();
            
            charts.latency = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Latency (ms)',
                        data: latencies.map(d => d.y),
                        borderColor: '#ffc107',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
        }

        function updateTimelineChart() {
            const byDate = historyData.reduce((acc, e) => {
                const date = new Date(e.created_at).toLocaleDateString();
                acc[date] = (acc[date] || 0) + 1;
                return acc;
            }, {});

            const ctx = document.getElementById('timelineChart').getContext('2d');
            if (charts.timeline) charts.timeline.destroy();
            
            charts.timeline = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(byDate),
                    datasets: [{
                        label: 'Evaluations',
                        data: Object.values(byDate),
                        backgroundColor: 'rgba(192, 192, 192, 0.7)'
                    }]
                },
                options: {
                    responsive: true,
                    scales: { y: { beginAtZero: true } }
                }
            });
        }

        function updateTable() {
            const tbody = document.getElementById('resultsBody');
            tbody.innerHTML = historyData.slice(0, 50).map(e => {
                const timestamp = new Date(e.created_at).toLocaleString();
                const prompt = (e.prompt || '').substring(0, 50) + '...';
                const verdict = e.judge_verdict || 'ERROR';
                const badgeClass = `verdict-${(verdict || 'error').toLowerCase()}`;
                const latency = e.model_output?.match(/\d+/)?.[0] || 'N/A';
                
                return `
                    <tr>
                        <td>${timestamp}</td>
                        <td>${e.model || 'N/A'}</td>
                        <td>${prompt}</td>
                        <td><span class="verdict-badge ${badgeClass}">${verdict.toUpperCase()}</span></td>
                        <td>${latency}ms</td>
                    </tr>
                `;
            }).join('');
        }

        connectWebSocket();
        fetchHistory();
        setInterval(fetchHistory, 30000);
    </script>
</body>
</html>
